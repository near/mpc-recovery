use super::message::PresignatureMessage;
use super::triple::{Triple, TripleId, TripleManager};
use crate::types::{PresignatureProtocol, PrivateKeyShare, PublicKey};
use crate::util::AffinePointExt;
use cait_sith::protocol::{Action, Participant};
use cait_sith::{KeygenOutput, PresignArguments, PresignOutput};
use k256::Secp256k1;
use std::collections::hash_map::Entry;
use std::collections::HashMap;

/// Unique number used to identify a specific ongoing presignature generation protocol.
/// Without `PresignatureId` it would be unclear where to route incoming cait-sith presignature
/// generation messages.
pub type PresignatureId = u64;

/// A completed presignature.
pub struct Presignature {
    pub id: u64,
    pub output: PresignOutput<Secp256k1>,
}

/// An ongoing presignature generator.
pub struct PresignatureGenerator {
    pub protocol: PresignatureProtocol,
    pub triple0: TripleId,
    pub triple1: TripleId,
}

/// Abstracts how triples are generated by providing a way to request a new triple that will be
/// complete some time in the future and a way to take an already generated triple.
pub struct PresignatureManager {
    /// Completed unspent presignatures.
    presignatures: HashMap<PresignatureId, Presignature>,
    /// Ongoing triple generation protocols.
    generators: HashMap<PresignatureId, PresignatureGenerator>,

    participants: Vec<Participant>,
    me: Participant,
    threshold: usize,
    epoch: u64,
}

impl PresignatureManager {
    pub fn new(
        participants: Vec<Participant>,
        me: Participant,
        threshold: usize,
        epoch: u64,
    ) -> Self {
        Self {
            presignatures: HashMap::new(),
            generators: HashMap::new(),
            participants,
            me,
            threshold,
            epoch,
        }
    }

    /// Returns the number of unspent presignatures available in the manager.
    pub fn len(&self) -> usize {
        self.presignatures.len()
    }

    /// Returns the number of unspent presignatures we will have in the manager once
    /// all ongoing generation protocols complete.
    pub fn potential_len(&self) -> usize {
        self.presignatures.len() + self.generators.len()
    }

    /// Starts a new presignature generation protocol.
    pub fn generate(
        &mut self,
        triple0: Triple,
        triple1: Triple,
        public_key: &PublicKey,
        private_share: &PrivateKeyShare,
    ) {
        let id = rand::random();
        tracing::info!(id, "starting protocol to generate a new presignature");
        let protocol = Box::new(
            cait_sith::presign(
                &self.participants,
                self.me,
                PresignArguments {
                    triple0: (triple0.share, triple0.public),
                    triple1: (triple1.share, triple1.public),
                    keygen_out: KeygenOutput {
                        private_share: *private_share,
                        public_key: *public_key,
                    },
                    threshold: self.threshold,
                },
            )
            .unwrap(),
        );
        self.generators.insert(
            id,
            PresignatureGenerator {
                protocol,
                triple0: triple0.id,
                triple1: triple1.id,
            },
        );
    }

    /// Ensures that the presignature with the given id is either:
    /// 1) Already generated in which case returns `None`, or
    /// 2) Is currently being generated by `protocol` in which case returns `Some(protocol)`, or
    /// 3) Has never been seen by the manager in which case start a new protocol and returns `Some(protocol)`, or
    /// 4) Depends on triples (`triple0`/`triple1`) that are unknown to the node
    // TODO: What if the presignature completed generation and is already spent?
    pub fn get_or_generate(
        &mut self,
        id: PresignatureId,
        triple0: TripleId,
        triple1: TripleId,
        triple_manager: &mut TripleManager,
        public_key: &PublicKey,
        private_share: &PrivateKeyShare,
    ) -> Option<&mut PresignatureProtocol> {
        if self.presignatures.contains_key(&id) {
            None
        } else {
            match self.generators.entry(id) {
                Entry::Vacant(entry) => {
                    tracing::info!(id, "joining protocol to generate a new presignature");
                    let triple0 = match triple_manager.take(triple0) {
                        Some(triple0) => triple0,
                        None => {
                            tracing::warn!(triple_id = triple0, "triple0 is missing, can't join");
                            return None;
                        }
                    };
                    let triple1 = match triple_manager.take(triple1) {
                        Some(triple1) => triple1,
                        None => {
                            tracing::warn!(triple_id = triple1, "triple1 is missing, can't join");
                            return None;
                        }
                    };
                    let protocol = Box::new(
                        cait_sith::presign(
                            &self.participants,
                            self.me,
                            PresignArguments {
                                triple0: (triple0.share, triple0.public),
                                triple1: (triple1.share, triple1.public),
                                keygen_out: KeygenOutput {
                                    private_share: *private_share,
                                    public_key: *public_key,
                                },
                                threshold: self.threshold,
                            },
                        )
                        .unwrap(),
                    );
                    Some(
                        &mut entry
                            .insert(PresignatureGenerator {
                                protocol,
                                triple0: triple0.id,
                                triple1: triple1.id,
                            })
                            .protocol,
                    )
                }
                Entry::Occupied(entry) => Some(&mut entry.into_mut().protocol),
            }
        }
    }

    /// Pokes all of the ongoing generation protocols and returns a vector of
    /// messages to be sent to the respective participant.
    ///
    /// An empty vector means we cannot progress until we receive a new message.
    pub fn poke(&mut self) -> Vec<(Participant, PresignatureMessage)> {
        let mut messages = Vec::new();
        self.generators.retain(|id, generator| loop {
            let action = generator.protocol.poke().unwrap();
            match action {
                Action::Wait => {
                    tracing::debug!("waiting");
                    // Retain protocol until we are finished
                    return true;
                }
                Action::SendMany(data) => {
                    for p in &self.participants {
                        messages.push((
                            *p,
                            PresignatureMessage {
                                id: *id,
                                triple0: generator.triple0,
                                triple1: generator.triple1,
                                epoch: self.epoch,
                                from: self.me,
                                data: data.clone(),
                            },
                        ))
                    }
                }
                Action::SendPrivate(p, data) => messages.push((
                    p,
                    PresignatureMessage {
                        id: *id,
                        triple0: generator.triple0,
                        triple1: generator.triple1,
                        epoch: self.epoch,
                        from: self.me,
                        data: data.clone(),
                    },
                )),
                Action::Return(output) => {
                    tracing::info!(
                        id,
                        big_r = ?output.big_r.into_base58(),
                        "completed presignature generation"
                    );
                    self.presignatures
                        .insert(*id, Presignature { id: *id, output });
                    // Do not retain the protocol
                    return false;
                }
            }
        });
        messages
    }
}
