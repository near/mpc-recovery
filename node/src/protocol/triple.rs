use super::message::TripleMessage;
use crate::types::TripleProtocol;
use crate::util::AffinePointExt;
use cait_sith::protocol::{Action, Participant};
use cait_sith::triples::TripleGenerationOutput;
use k256::Secp256k1;
use std::collections::btree_map::Entry;
use std::collections::BTreeMap;

/// Unique number used to identify a specific ongoing triple generation protocol.
/// Without `TripleId` it would be unclear where to route incoming cait-sith triple generation
/// messages.
pub type TripleId = u64;

/// Abstracts how triples are generated by providing a way to request a new triple that will be
/// complete some time in the future and a way to take an already generated triple.
pub struct TripleManager {
    /// Completed unspent triples
    // TODO: I put these into `BTreeMap` so we can potentially use the ordering for choosing which
    // triple to use for consensus, but it might not be necessary.
    triples: BTreeMap<TripleId, TripleGenerationOutput<Secp256k1>>,
    /// Ongoing triple generation protocols
    generators: BTreeMap<TripleId, TripleProtocol>,

    participants: Vec<Participant>,
    me: Participant,
    threshold: usize,
    epoch: u64,
}

impl TripleManager {
    pub fn new(
        participants: Vec<Participant>,
        me: Participant,
        threshold: usize,
        epoch: u64,
    ) -> Self {
        Self {
            triples: BTreeMap::new(),
            generators: BTreeMap::new(),
            participants,
            me,
            threshold,
            epoch,
        }
    }

    /// Returns the number of unspent triples available in the manager.
    pub fn len(&self) -> usize {
        self.triples.len()
    }

    /// Returns the number of unspent triples we will have in the manager once
    /// all ongoing generation protocols complete.
    pub fn potential_len(&self) -> usize {
        self.triples.len() + self.generators.len()
    }

    /// Starts a new Beaver triple generation protocol.
    pub fn generate(&mut self) {
        let id = rand::random();
        tracing::info!(id, "starting protocol to generate a new triple");
        let protocol: TripleProtocol = Box::new(
            cait_sith::triples::generate_triple(&self.participants, self.me, self.threshold)
                .unwrap(),
        );
        self.generators.insert(id, protocol);
    }

    /// Take an unspent triple by its id with no way to return it.
    /// It is very important to NOT reuse the same triple twice for two different
    /// protocols.
    pub fn take(&mut self, id: TripleId) -> Option<TripleGenerationOutput<Secp256k1>> {
        match self.triples.entry(id) {
            Entry::Vacant(_) => None,
            Entry::Occupied(entry) => Some(entry.remove()),
        }
    }

    /// Ensures that the triple with the given id is either:
    /// 1) Already generated in which case returns `None`, or
    /// 2) Is currently being generated by `protocol` in which case returns `Some(protocol)`, or
    /// 3) Has never been seen by the manager in which case start a new protocol and returns `Some(protocol)`
    // TODO: What if the triple completed generation and is already spent?
    pub fn get_or_generate(&mut self, id: TripleId) -> Option<&mut TripleProtocol> {
        if self.triples.contains_key(&id) {
            None
        } else {
            Some(self.generators.entry(id).or_insert_with(|| {
                tracing::info!(id, "joining protocol to generate a new triple");
                Box::new(
                    cait_sith::triples::generate_triple(
                        &self.participants,
                        self.me,
                        self.threshold,
                    )
                    .unwrap(),
                )
            }))
        }
    }

    /// Pokes all of the ongoing generation protocols and returns a vector of
    /// messages to be sent to the respective participant.
    ///
    /// An empty vector means we cannot progress until we receive a new message.
    pub fn poke(&mut self) -> Vec<(Participant, TripleMessage)> {
        let mut messages = Vec::new();
        self.generators.retain(|id, protocol| loop {
            let action = protocol.poke().unwrap();
            match action {
                Action::Wait => {
                    tracing::debug!("waiting");
                    // Retain protocol until we are finished
                    return true;
                }
                Action::SendMany(data) => {
                    for p in &self.participants {
                        messages.push((
                            *p,
                            TripleMessage {
                                id: *id,
                                epoch: self.epoch,
                                from: self.me,
                                data: data.clone(),
                            },
                        ))
                    }
                }
                Action::SendPrivate(p, data) => messages.push((
                    p,
                    TripleMessage {
                        id: *id,
                        epoch: self.epoch,
                        from: self.me,
                        data: data.clone(),
                    },
                )),
                Action::Return(output) => {
                    tracing::info!(
                        id,
                        big_a = ?output.1.big_a.into_base58(),
                        big_b = ?output.1.big_b.into_base58(),
                        big_c = ?output.1.big_c.into_base58(),
                        "completed triple generation"
                    );
                    self.triples.insert(*id, output);
                    // Do not retain the protocol
                    return false;
                }
            }
        });
        messages
    }
}
